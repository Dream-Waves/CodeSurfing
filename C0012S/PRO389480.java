/*
Lv. 2 #389480 - 완전범죄

    문제 설명
        A도둑과 B도둑이 팀을 이루어 모든 물건을 훔치려고 합니다. 단, 각 도둑이 물건을 훔칠 때 남기는 흔적이 누적되면 경찰에 붙잡히기 때문에, 두 도둑 중 누구도 경찰에 붙잡히지 않도록 흔적을 최소화해야 합니다.

        물건을 훔칠 때 조건은 아래와 같습니다.
            · 물건 i를 훔칠 때,
                · A도둑이 훔치면 info[i][0]개의 A에 대한 흔적을 남깁니다.
                · B도둑이 훔치면 info[i][1]개의 B에 대한 흔적을 남깁니다.
            · 각 물건에 대해 A도둑과 B도둑이 남기는 흔적의 개수는 1 이상 3 이하입니다.

        경찰에 붙잡히는 조건은 아래와 같습니다.
            · A도둑은 자신이 남긴 흔적의 누적 개수가 n개 이상이면 경찰에 붙잡힙니다.
            · B도둑은 자신이 남긴 흔적의 누적 개수가 m개 이상이면 경찰에 붙잡힙니다.

        각 물건을 훔칠 때 생기는 흔적에 대한 정보를 담은 2차원 정수 배열 info, A도둑이 경찰에 붙잡히는 최소 흔적 개수를 나타내는 정수 n, B도둑이 경찰에 붙잡히는 최소 흔적 개수를 나타내는 정수 m이 매개변수로 주어집니다. 두 도둑 모두 경찰에 붙잡히지 않도록 모든 물건을 훔쳤을 때, A도둑이 남긴 흔적의 누적 개수의 최솟값을 return 하도록 solution 함수를 완성해 주세요. 만약 어떠한 방법으로도 두 도둑 모두 경찰에 붙잡히지 않게 할 수 없다면 -1을 return해 주세요.


    제한사항
        · 1 ≤ info의 길이 ≤ 40
            · info[i]는 물건 i를 훔칠 때 생기는 흔적의 개수를 나타내며, [A에 대한 흔적 개수, B에 대한 흔적 개수]의 형태입니다.
            · 1 ≤ 흔적 개수 ≤ 3
        · 1 ≤ n ≤ 120
        · 1 ≤ m ≤ 120


    테스트 케이스 구성 안내
        아래는 테스트 케이스 구성을 나타냅니다. 각 그룹 내의 테스트 케이스를 모두 통과하면 해당 그룹에 할당된 점수를 획득할 수 있습니다.
            그룹	    총점	    테스트 케이스 그룹 설명
            #1	    15%	    info[i][1] = 1
            #2	    40%	    info의 길이 ≤ 20
            #3	    45%	    추가 제한 사항 없음


    입출력 예
        info	                    n	m	result
        [[1, 2], [2, 3], [2, 1]]	4	4	2
        [[1, 2], [2, 3], [2, 1]]	1	7	0
        [[3, 3], [3, 3]]	        7	1	6
        [[3, 3], [3, 3]]	        6	1	-1


    입출력 예 설명
        입출력 예 #1
            첫 번째와 세 번째 물건을 B도둑이 훔치고 두 번째 물건을 A도둑이 훔치면, A도둑에 대한 흔적은 총 2개이고 B도둑에 대한 흔적은 총 3개입니다. 목표를 달성하면서 A도둑에 대한 흔적 개수를 2보다 더 낮게 만들 수 없습니다.
            따라서 2를 return 해야 합니다.

        입출력 예 #2
            B도둑이 모든 물건을 훔쳐도 B의 흔적이 7개 이상 쌓이지 않습니다.
            따라서 A도둑의 흔적은 최소 0이 되며, 0을 return 해야 합니다.

        입출력 예 #3
            B도둑이 한 번이라도 물건을 훔치면 B의 흔적이 최소 1개 이상 남습니다. 따라서 모든 물건을 A도둑이 훔쳐야 하며, 이 경우에도 A의 흔적은 7개 미만입니다.
            따라서, A도둑이 모든 물건을 훔칠 때의 흔적 개수 6을 return 해야 합니다.

        입출력 예 #4
            어떤 방법으로도 두 도둑 모두 경찰에 붙잡히지 않고 모든 물건을 훔칠 수 없습니다.
            따라서 -1을 return 해야 합니다.
*/


/*
    정확성  테스트
        테스트 1 〉    통과 (0.06ms, 92.6MB)
        테스트 2 〉    통과 (0.06ms, 86.6MB)
        테스트 3 〉    통과 (0.07ms, 94.8MB)
        테스트 4 〉    통과 (0.21ms, 95MB)
        테스트 5 〉    통과 (0.29ms, 89.6MB)
        테스트 6 〉    통과 (0.13ms, 79.5MB)
        테스트 7 〉    통과 (0.14ms, 75.5MB)
        테스트 8 〉    통과 (0.23ms, 78.9MB)
        테스트 9 〉    통과 (0.16ms, 79.4MB)
        테스트 10 〉    통과 (0.24ms, 87.3MB)
        테스트 11 〉    통과 (0.04ms, 76.8MB)
        테스트 12 〉    통과 (0.06ms, 69.9MB)
        테스트 13 〉    통과 (0.07ms, 76MB)
        테스트 14 〉    통과 (0.04ms, 87.5MB)
        테스트 15 〉    통과 (0.18ms, 71.4MB)
        테스트 16 〉    통과 (0.07ms, 71.4MB)
        테스트 17 〉    통과 (0.07ms, 79.8MB)
        테스트 18 〉    통과 (0.06ms, 80.2MB)
        테스트 19 〉    통과 (0.07ms, 87.8MB)
        테스트 20 〉    통과 (0.22ms, 90.6MB)
        테스트 21 〉    통과 (0.05ms, 75.5MB)
        테스트 22 〉    통과 (0.09ms, 94MB)
        테스트 23 〉    통과 (0.12ms, 83.9MB)
        테스트 24 〉    통과 (0.21ms, 95.3MB)
        테스트 25 〉    통과 (0.43ms, 71.7MB)
        테스트 26 〉    통과 (0.22ms, 84MB)
        테스트 27 〉    통과 (0.42ms, 88.2MB)
        테스트 28 〉    통과 (0.34ms, 85.2MB)
        테스트 29 〉    통과 (0.22ms, 86.4MB)
        테스트 30 〉    통과 (0.44ms, 94.1MB)
        테스트 31 〉    통과 (0.14ms, 87.3MB)
        테스트 32 〉    통과 (0.38ms, 79.3MB)
        테스트 33 〉    통과 (0.41ms, 86.7MB)
        테스트 34 〉    통과 (0.44ms, 85.9MB)
        테스트 35 〉    통과 (0.20ms, 85.7MB)
        테스트 36 〉    통과 (0.49ms, 87.6MB)
        테스트 37 〉    통과 (0.11ms, 86.5MB)
        테스트 38 〉    통과 (0.04ms, 92.3MB)
        테스트 39 〉    통과 (0.04ms, 86.3MB)

    채점 결과
        정확성: 100.0
        합계: 100.0 / 100.0
*/


// 정답

package C0012S;

import java.util.*;

class PRO389480 {
    int size; // 물건의 개수
    int[][] trace; // trace[r][c] : r 번째 물건까지 훔칠 경우, B 도둑이 물건을 훔쳐 남긴 흔적들의 합이 c일 때 A 도둑이 남길 수 있는 흔적의 최솟값
    final int MAX_TRACE = 120; // 도둑이 물건을 훔칠 때 남기는 흔적의 최댓값

    public void init(int[][] info, int m) { // 문제와 관련된 정보를 초기화하는 메서드
        size = info.length;
        trace = new int[size + 1][m];

        for (int i = 0; i <= size; i++) {
            Arrays.fill(trace[i], MAX_TRACE);
        }
    }

    public int find(int[][] info, int m) { // A 도둑과 B 도둑 모두 붙잡히지 않도록 모든 물건을 훔쳤을 때, A 도둑이 남긴 흔적의 누적 개수의 최솟값을 구하는 메서드
        trace[0][0] = 0; // 아무런 물건을 훔치지 않아 남은 흔적이 0

        for (int r = 1; r <= size; r++) {
            for (int c = 0; c < m; c++) {
                // A가 물건을 훔칠 경우
                trace[r][c] = Math.min(trace[r][c], trace[r - 1][c] + info[r - 1][0]);

                // B가 물건을 훔칠 경우
                if ((c + info[r - 1][1]) < m) { // B 도둑이 지금까지 물건을 훔치면서 남길 모든 흔적들의 개수가 B 도둑이 경찰에 잡힐 수 있는 흔적의 누적 개수의 최솟값보다 작을 경우
                    trace[r][c + info[r - 1][1]] = Math.min(trace[r][c + info[r - 1][1]], trace[r - 1][c]);
                }
            }
        }

        int answer = MAX_TRACE; // A 도둑과 B 도둑 모두 붙잡히지 않도록 모든 물건을 훔쳤을 때, A 도둑이 남긴 흔적의 누적 개수의 최솟값
        for (int a = 0; a < m; a++) {
            answer = Math.min(trace[size][a], answer);
        }

        return answer;
    }

    public int solution(int[][] info, int n, int m) {
        init(info, m);

        int answer = find(info, m);

        return answer >= n ? -1 : answer; // A 도둑이 남길 수 있는 흔적의 최솟값이 A 도둑이 경찰에 잡힐 수 있는 흔적의 누적 개수의 최솟값보다 크거나 같을 경우 -1을 반환하고, 아닐 경우 A 도둑이 남길 수 있는 흔적의 최솟값을 반환
    }
}
